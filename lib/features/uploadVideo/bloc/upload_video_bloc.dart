// file_upload_bloc.dartimport 'dart:async';import 'dart:io';import 'package:bloc/bloc.dart';import 'package:believersHub/features/uploadVideo/model/upload_status.dart';import 'package:believersHub/features/uploadVideo/upload_video_repo/video_upload_repository.dart';import 'package:equatable/equatable.dart';import 'upload_video_events.dart';import 'upload_video_states.dart';class FileUploadBloc extends Bloc<FileUploadEvents, FileUploadStates> {  final VideoUploadRepository videoUploadRepository;  StreamSubscription<double>? _progressSub;  FileUploadBloc({required this.videoUploadRepository}) : super(VideoUploadInitState()) {    on<CallVideoUploadRequest>(_onCallVideoUploadRequest);    on<CallVideoUploadToS3>(_onCallVideoUploadToS3);    on<CallVideoUploadComplete>(_onCallVideoUploadComplete);    on<CallVideoUploadPollingEVent>(_onCallVideoUploadPollingEVent);    on<CancelUploadEvent>((event, emit) async {      videoUploadRepository.cancelUpload(); // stop S3 upload      emit(VideoUploadCancelledState());    });    on<CallDiscardUpload>((event, emit) async {      final res = await videoUploadRepository.discardUpload(event.uploadId);      if (res.success) {        emit(DiscardUploadSuccess());      } else {        emit(DiscardUploadFailed(res.message ?? "Discard failed"));      }    });    // control events for progress/processing/done    on<UploadProgressEvent>((event, emit) {      emit(VideoUploadProgressState(event.progress));    });    on<UploadStartedEvent>((event, emit) {      emit(VideoUploadUploadingState());    });    on<UploadCompletedEvent>((event, emit) {      emit(VideoUploadProcessingState());    });    on<ProcessingStartedEvent>((event, emit) {      emit(VideoUploadProcessingState());    });    on<ProcessingCompletedEvent>((event, emit) {      emit(VideoUploadDoneState(event.uploadStatusResponse));    });  }  Future<void> _onCallVideoUploadRequest(      CallVideoUploadRequest event,      Emitter<FileUploadStates> emit,      ) async {    emit(VideoUploadLoadingState());    final result = await videoUploadRepository.requestVideoUpload(event.videoUploadRequest);    if (result.success) {      emit(VideoUploadRequestSuccess(result.data));    } else {      emit(VideoUploadRequestFailed(result.message!));    }  }  Future<void> _onCallVideoUploadToS3(      CallVideoUploadToS3 event,      Emitter<FileUploadStates> emit,      ) async {    // notify UI that upload started    add(UploadStartedEvent());    // run upload with progress callback    final result = await videoUploadRepository.uploadToS3(      event.signedUrl,      event.file,          (progress) {        add(UploadProgressEvent(progress));      },    );    if (result.success) {      // notify UI that upload finished and processing will start      add(UploadCompletedEvent());    } else {      emit(VideoUploadS3Failed(result.message ?? "Upload failed"));    }  }  Future<void> _onCallVideoUploadComplete(      CallVideoUploadComplete event,      Emitter<FileUploadStates> emit,      ) async {    final result = await videoUploadRepository.completeVideoUpload(event.uploadId, event.fileKey);    if (result.success) {      add(ProcessingStartedEvent());    } else {      emit(VideoUploadCompleteFailed(result.message ?? "Complete failed"));    }  }  Future<void> _onCallVideoUploadPollingEVent(      CallVideoUploadPollingEVent event,      Emitter<FileUploadStates> emit,      ) async {    // Polling informs about worker status; translate to processing/done states    if (event.status != "done") {      add(ProcessingStartedEvent());    } else {      add(ProcessingCompletedEvent(event.uploadStatusResponse));    }  }  @override  Future<void> close() {    _progressSub?.cancel();    return super.close();  }}